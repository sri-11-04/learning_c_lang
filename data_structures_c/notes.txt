âš”ï¸ Phase 3: Data Structures in C â€” 100% Challenge-Based Roadmap

Each topic has 3 levels:

ğŸŸ¢ Core â†’ Build the structure from scratch

ğŸŸ¡ Intermediate â†’ Add operations, optimizations

ğŸ”´ Advanced â†’ Apply it in real-world logic or problem-solving

ğŸ§© Week 1â€“2: Linked Lists
Challenge 1 â€” Build Your First Singly Linked List

Create a struct Node and manually link nodes using pointers.
Goal: Print all values in order.

Challenge 2 â€” Implement list.append()

Add a function that appends elements to the end of a linked list.

Challenge 3 â€” Insert Anywhere

Add a function that inserts at any position (head, middle, tail).

Challenge 4 â€” Reverse It!

Reverse the linked list in place (without creating a new list).

Challenge 5 â€” Detect Loop

Create a loop intentionally and write code to detect it (Floydâ€™s algorithm).

Bonus:

Convert your singly list to doubly and circular linked lists.

ğŸ§  Week 3â€“4: Stacks & Queues
Challenge 6 â€” Stack Using Array

Implement push, pop, peek, isEmpty, isFull.

Challenge 7 â€” Stack Using Linked List

Same operations, but with nodes.

Challenge 8 â€” Balanced Parentheses Checker

Validate if â€œ(a+b)â€ or â€œ((a+b])â€ is balanced using stack.

Challenge 9 â€” Queue Using Array

Implement enqueue, dequeue, peek, and handle overflow/underflow.

Challenge 10 â€” Circular Queue

Implement circular queue logic (front and rear wrap-around).

ğŸŒ³ Week 5â€“6: Trees
Challenge 11 â€” Binary Tree Creation

Build a binary tree manually, node by node, using struct pointers.

Challenge 12 â€” Traversals (Recursive + Iterative)

Preorder, Inorder, Postorder traversal.

Challenge 13 â€” Binary Search Tree (BST)

Insert, search, and delete nodes in a BST.

Challenge 14 â€” Height of a Tree

Write a function to find the height recursively.

Challenge 15 â€” Level Order Traversal

Implement BFS traversal of a tree using a queue.

ğŸ•¸ï¸ Week 7â€“8: Graphs
Challenge 16 â€” Graph Representation

Build a graph using adjacency list.

Challenge 17 â€” Depth First Search (DFS)

Implement DFS using stack or recursion.

Challenge 18 â€” Breadth First Search (BFS)

Implement BFS using queue.

Challenge 19 â€” Maze Solver (BFS Special)

Represent a maze as a grid, and find shortest path using BFS.

Challenge 20 â€” Cycle Detection

Detect if a directed/undirected graph contains a cycle.

âš™ï¸ Week 9â€“10: Sorting & Searching
Challenge 21 â€” Linear & Binary Search

Implement both search types manually.

Challenge 22 â€” Bubble Sort

Sort array step-by-step and count swaps.

Challenge 23 â€” Merge Sort

Implement recursive merge sort.

Challenge 24 â€” Quick Sort

Implement quick sort with pivot and recursion.

Challenge 25 â€” Dictionary with Hash Table

Build a keyâ€“value store using hashing and linked lists for collision.

ğŸ Week 11â€“12: Capstone Challenges
Challenge 26 â€” DS Playground

Menu-driven console app: user chooses a DS (stack, queue, tree, etc.), performs operations interactively.

Challenge 27 â€” Maze Solver 2.0

Enhanced BFS + backtracking to print the path visually (grid output).

Challenge 28 â€” Mini Memory Manager

Use linked list to simulate malloc/free allocation tracking.